# LongestUniquePalindromesFinder
find k longest unique palindrome substrings in a string

Joseph Potashnik

## Function descripton

#### LongestUniquePalindromes GetLongestUniquePalindromes(int numOfPalindromes, string s)

**numOfPalindromes**: a positive int

**s**: non-null string

**return value**: LongestUniquePalindromes is a class for storing the results.

LongestUniquePalindromes contains a list of Palindromes with their lengths and indices in the strings.
From a client perspective, the class exposes an overloaded ToString() which the client then can use to print the results.

Runtime Complexity: O(n^3)

## Project description

The solution contains (i) .NET core DLL (2.0), which can be built and run cross-platform, (ii) xUnit .NET core unit tests.


In windows: open the solution file in an IDE and build (.NET core is required)


In unix: use "dotnet build" and "dotnet test" respectively.

## Thought process:

What is a palindrome? A string s such that its reverse (its characters in a reverse order) equals to s.  A bit more formally, the palindrome language is generated by the context-free grammar.

* S -> ϵ; S is the Start Symbol.
* S-> x  ; x ∈ Sigma, The characters Alphhabet
* S -> xSx

From the definition of the palindrome language two basic results immediately follow. First, the empty string is a palindrome of length 0. Second, any single character is also a palindrome of length 1. Thus, a string with n unique characters has at least n unique palindromes (of length 1).

Tests: 
* Test that the empty string is a palindrome.
* Test that a character is a palindrome

The next thing I thought about is how to recognize a palindrome. There are many ways to do it. Theoretically, we could use a non-deterministic Finite Automata to find if a string of an unknown length is a palindrome (by pushing and popping from a stack; the non-deterministic part is required to handle both odd and even-length palindromes). However, for our purposes this is probably an overkill and incurs more data structures to maintain, harder to follow computation.
I will assume here that the length of the string is given, n. I will also assume that strings do not have more than 2^31 characters (string.Length in .NET is an integer).


So, given length n,
n == 1 or n == 0: by definition, a palindrome.
n > 1 :  we could traverse simultaneously the string from both ends and compare characters, i.e, a for-loop needs to traverse only half of the characters. There is subtle point here whether the length is even or odd. So, let us take two examples to verify the exact upper bound.

Example 1: “abba” n = 4, n / 2 = 2. In this case, n/2 is exactly correct. An even-string will be a palindrome if s[i] == s[n-i-1] for n/2 characters.
Example 2: “abxba” n = 5, n / 2 = 2 (rounded down). In this case, we have not traversed the middle character, but this is OK – it doesn’t matter what it is, because by definition any single character is a palindrome.

Possible Tests in this point:
* Test that a certain even-length string, say “abba”, is a palindrome, and that the test passes.
* Test that a certain odd-length string, say “abbca”, is a palindrome, and the test passes.
* Test that a certain string, say “abcc” is not a palindrome, and that the test passes.
* Test that the empty string is a palindrome and the test passes.
* Test that a single character is a palindrome and the test passes.
* Test that a null string arguments causes a NullArgumentException.

Last step: we are now armed with a function that recognizes whether a string of length n is a palindrome.  We would like to find the 3 longest unique substrings of a given string s that are palindromes. It is better to program for extension, so let us change the task slightly and find the (at most) k longest unique palindromes.

Questions: what is "Longest" and "Unique"?
Answers: 
* "Longest" is a maximal length palindrome whose internal in the string is not contained by any other palindrome.
* "Unique" means that there is only one palindrome substring with a certain length. If two or more exist with the same string composition, none of them is unique.

So, what I had in mind is the following algorithm: we will examine decreasing-length partitions of the original string for palindromes. We test each substring, if it is a palindrome, we check against list of previously obtained longest palindromes. If it is not contained in the list, we add the palindrome to the set, given that is Longest and Unique. 
Furthermore, even if we have already found k palindromes, we cannot be greedy and return. We still must traverse all partitions of the same length because we may find out in a later stage that the palindrome we encountered was repeated, hence not unique, and must be removed from the list of longest unique palindromes.

Since we search by decreasing order, these results are guaranteed to the be the longest unique palindromes. 
If we have finished the traversal over all possible partitions and still have not arrived to k palindromes, add the Empty String to the list  and return. In this case, the client will have at most k palindromes.

Also should be made explicit: there could be several equally long unique longest palindromes. For instance, the string “abcd” has four 1-length unique palindromes. The algorithm proposed above terminates when it finds a possible solution. 

Assumption: the list the algorithm returns is sorted in a descending order of the palindromes’ length.

So, a sketch a run on a string “abcabba” could be described as:
* Search partitions of length n : is “abcabba” a palindrome?
* Search 2 partitions of length n-1 : are “abcabb” and “bcabba” palindromes?
* Search 3 partitions of length n-2: are “abcab”, “bcabb”, “cabba” palindromes?
* …..
* Search (if not returned by now) n partitions of length 1: “a”, “b”, “c”, “a”, “b”, “b”, “a”.

Possible Tests:
* Test whether a palindrome is the longest (tests for both true and false cases)
* Test whether a palindrome is unique (tests for both true and false cases)
* Test that a null string arguments causes a NullArgumentException
* Test that the number of desired palindromes k is a positive integer
* Test the palindrome from the specification of the task ("sqrrqabccbatudefggfedvwhijkllkjihxymnnmzpop")
* Tests for a string having less than k palindromes 
* Tests for a string having exactly k palindromes
* Tests for a string having more than k palindromes


Complexity Analysis: We employ an outer loop for decreasing lengths (O(n)), and an inner loop that goes over all partitions in this length (O(n)). The inner loops calls to a function that identifies a palindrome, running in O(n). Overall, Complexity is O(n^3)


